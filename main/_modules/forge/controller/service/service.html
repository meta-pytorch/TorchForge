
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>forge.controller.service.service &#8212; torchforge 0.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=047068a3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=b61afe48" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
    <script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: false,
    theme: 'base',
    themeVariables: {
        primaryColor: '#4CAF50',
        primaryTextColor: '#000',
        primaryBorderColor: '#fff',
        lineColor: '#555',
        secondaryColor: '#FF9800',
        tertiaryColor: '#ffffde'
    },
    flowchart: {
        curve: 'basis'
    },
    themeCSS: '.edgePath .path { stroke-width: 4px; stroke: #555; }'
});
</script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";
window.addEventListener("load", () => mermaid.run());
</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/forge/controller/service/service';</script>
    <script src="../../../../_static/custom.js?v=0065d487"></script>
    <link rel="canonical" href="https://meta-pytorch.org/torchforge/main/_modules/forge/controller/service/service.html" />
    <link rel="icon" href="../../../../_static/logo-icon.svg"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/2.3.1/list.min.js"></script>
<script>
  if (window.location.hostname === 'docs.pytorch.org' || window.location.hostname === 'docs-preview.pytorch.org') {
    const script = document.createElement('script');
    script.src = 'https://cmp.osano.com/16A0DbT9yDNIaQkvZ/31b1b91a-e0b6-47ea-bde2-7f2bd13dbe5c/osano.js?variant=one';
    document.head.appendChild(script);
  }
</script>
<script>
  // Cookie banner for non-LF projects
  document.addEventListener('DOMContentLoaded', function () {
    // Hide cookie banner on local environments and LF owned docs
    if (window.location.hostname === 'localhost' ||
      window.location.hostname === '0.0.0.0' ||
      window.location.hostname === '127.0.0.1' ||
      window.location.hostname === 'docs.pytorch.org' ||
      window.location.hostname === 'docs-preview.pytorch.org' ||
      window.location.hostname.startsWith('192.168.')) {
      const banner = document.querySelector('.cookie-banner-wrapper');
      if (banner) {
        banner.style.display = 'none';
      }
    }
  });
</script>
<!-- Conditional CSS for header and footer height adjustment -->

<style>
  :root {
    --header-height: 0px !important;
    --header-height-desktop: 0px !important;
  }
</style>


<style>
  @media (min-width: 1100px) {
    .site-footer {
      height: 300px !important;
    }
  }
</style>

<link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css" crossorigin="anonymous">
<script type="text/javascript" src="../../../../_static/js/theme.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400&display=swap" rel="stylesheet">
<meta property="og:image" content="../../../../_static/img/pytorch_seo.png" />
<link rel="stylesheet" href="../../../../_static/webfonts/all.min.css" crossorigin="anonymous">
<meta http-equiv="Content-Security-Policy"
  content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; style-src * 'unsafe-inline'; script-src * 'unsafe-inline' 'unsafe-eval' blob:;">
<meta name="pytorch_project" content="">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NPLPKN5G" height="0" width="0"
    style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- Google Tag Manager -->
<script>(function (w, d, s, l, i) {
    w[l] = w[l] || []; w[l].push({
      'gtm.start':
        new Date().getTime(), event: 'gtm.js'
    }); var f = d.getElementsByTagName(s)[0],
      j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
        'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    j.onload = function () {
      window.dispatchEvent(new Event('gtm_loaded'));
      console.log('GTM loaded successfully');
    };
  })(window, document, 'script', 'dataLayer', 'GTM-NPLPKN5G');
</script>
<!-- End Google Tag Manager -->
<!-- Facebook Pixel Code -->
<script>
  !function (f, b, e, v, n, t, s) {
    if (f.fbq) return; n = f.fbq = function () {
      n.callMethod ?
        n.callMethod.apply(n, arguments) : n.queue.push(arguments)
    };
    if (!f._fbq) f._fbq = n; n.push = n; n.loaded = !0; n.version = '2.0';
    n.queue = []; t = b.createElement(e); t.async = !0;
    t.src = v; s = b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t, s)
  }(window, document, 'script',
    'https://connect.facebook.net/en_US/fbevents.js');
  fbq('init', '243028289693773');
  fbq('track', 'PageView');
</script>
<script>
  document.documentElement.setAttribute('data-version', '');
</script>
<noscript>
  <img height="1" width="1" src="https://www.facebook.com/tr?id=243028289693773&ev=PageView&noscript=1" />
</noscript>
<script>
  function gtag() {
    window.dataLayer.push(arguments);
  }
</script>
<!-- End Facebook Pixel Code -->
<!-- Repository configuration for tutorials -->

<script>
  // Define repository configuration for tutorial buttons using existing html_context variables
  // Only injected when tutorial buttons are shown AND github variables are defined
  // If either condition is false, JavaScript will fallback to default PyTorch tutorial links
  window.repoConfig = {
    github_repo: "meta-pytorch/torchforge",
    github_branch: "main",
    colab_repo: "meta-pytorch/torchforge",
    colab_branch: "gh-pages"
  };
</script>

<!-- Script to Fix scrolling -->
<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Fix anchor scrolling
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const targetId = this.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);

        if (targetElement) {
          const headerHeight =
            (document.querySelector('.header-holder') ? document.querySelector('.header-holder').offsetHeight : 0) +
            (document.querySelector('.bd-header') ? document.querySelector('.bd-header').offsetHeight : 0) + 20;

          const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - headerHeight;
          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
          });

          // Update URL hash without scrolling
          history.pushState(null, null, '#' + targetId);
        }
      });
    });
  });
</script>

<script async src="https://cse.google.com/cse.js?cx=e65585f8c3ea1440e"></script>


  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>

  </head>

<body data-feedback-url="https://github.com/meta-pytorch/forge" class="pytorch-body">
  
  
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Home</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../getting_started.html">
    Getting Started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../tutorials.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api.html">
    API Reference
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
  
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
</div>
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/meta-pytorch/torchforge" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discuss.pytorch.org/" title="Discourse" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Discourse</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torchforge/" title="PyPi" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPi</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../getting_started.html">
    Getting Started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../tutorials.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api.html">
    API Reference
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
  
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
</div>
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/meta-pytorch/torchforge" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discuss.pytorch.org/" title="Discourse" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Discourse</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torchforge/" title="PyPi" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPi</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">forge.contro...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-behavior="tutorial-rating" data-count="1" data-value="1">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="2" data-value="2">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="3" data-value="3">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="4" data-value="4">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="5" data-value="5">★</span>
        
    </div>
</div>
</div>
      
    </div>
  
</div>
</div>
              
              
  
<div id="searchbox"></div>
  <article class="bd-article" id="pytorch-article">
    <!-- Hidden breadcrumb schema for SEO only -->
    <div style="display:none;" itemscope itemtype="https://schema.org/BreadcrumbList">
      
      <div itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <link itemprop="item" href="../../../index.html">
        <meta itemprop="name" content="Module code">
        <meta itemprop="position" content="1">
      </div>
      
      <div itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <meta itemprop="name" content="forge.controller.service.service">
        <meta itemprop="position" content="2">
      </div>
    </div>

    
    
    <div class="pytorch-call-to-action-links">
      <div id="tutorial-type">_modules/forge/controller/service/service</div>
      <a id="colab-link" data-behavior="call-to-action-event" data-response="Run in Google Colab" target="_blank">
        <div id="google-colab-link">
          <img class="call-to-action-img" src="../../../../_static/img/pytorch-colab.svg" />
          <div class="call-to-action-desktop-view">Run in Google Colab</div>
          <div class="call-to-action-mobile-view">Colab</div>
        </div>
      </a>
      <a id="notebook-link" data-behavior="call-to-action-event" data-response="Download Notebook">
        <div id="download-notebook-link">
          <img class="call-to-action-notebook-img" src="../../../../_static/img/pytorch-download.svg" />
          <div class="call-to-action-desktop-view">Download Notebook</div>
          <div class="call-to-action-mobile-view">Notebook</div>
        </div>
      </a>
      <a id="github-link" data-behavior="call-to-action-event" data-response="View on Github" target="_blank">
        <div id="github-view-link">
          <img class="call-to-action-img" src="../../../../_static/img/pytorch-github.svg" />
          <div class="call-to-action-desktop-view">View on GitHub</div>
          <div class="call-to-action-mobile-view">GitHub</div>
        </div>
      </a>
    </div>
    

    
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for forge.controller.service.service</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the BSD-style license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Distributed Actor Service Controller</span>

<span class="sd">This module provides a robust service orchestration system for managing distributed</span>
<span class="sd">actor-based workloads with automatic scaling, fault tolerance, and intelligent load balancing.</span>

<span class="sd">The main Service class acts as a singleton controller that handles:</span>
<span class="sd">- Fault tolerance with automatic replica recovery</span>
<span class="sd">- Autoscaling based on real-time metrics</span>
<span class="sd">- Load balancing across healthy replicas</span>
<span class="sd">- Session management with context propagation</span>
<span class="sd">- Comprehensive metrics collection and monitoring</span>

<span class="sd">Example:</span>
<span class="sd">    Basic service setup:</span>

<span class="sd">    &gt;&gt;&gt; config = ServiceConfig(</span>
<span class="sd">    ...     gpus_per_replica=1,</span>
<span class="sd">    ...     num_replicas=3</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; service = Service(config, MyActorClass, *args, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; await service.__initialize__()</span>

<span class="sd">    Session-based usage:</span>

<span class="sd">    &gt;&gt;&gt; async with service.session():</span>
<span class="sd">    ...     result = await service.my_endpoint(arg1, arg2)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pprint</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">monarch.actor</span><span class="w"> </span><span class="kn">import</span> <span class="n">Actor</span><span class="p">,</span> <span class="n">endpoint</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">forge.controller.service.interface</span><span class="w"> </span><span class="kn">import</span> <span class="n">_session_context</span><span class="p">,</span> <span class="n">Session</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">forge.controller.service.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">ServiceMetrics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">forge.controller.service.replica</span><span class="w"> </span><span class="kn">import</span> <span class="n">Replica</span><span class="p">,</span> <span class="n">ServiceRequest</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">forge.controller.service.router</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">LeastLoadedRouter</span><span class="p">,</span>
    <span class="n">RoundRobinRouter</span><span class="p">,</span>
    <span class="n">SessionRouter</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">forge.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">ServiceConfig</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>


<div class="viewcode-block" id="Service">
<a class="viewcode-back" href="../../../../api_service.html#forge.controller.service.service.Service">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Service</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Actor-less implementation of Service.</span>

<span class="sd">    This is a temporary solution to disable nested actors, which is proving</span>
<span class="sd">    problematic temporarily.</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg: Service configuration including number of replicas, GPUs per replica, and health polling rate</span>
<span class="sd">        actor_def: Actor class definition to instantiate on each replica</span>
<span class="sd">        *actor_args: Positional arguments passed to actor constructor</span>
<span class="sd">        **actor_kwargs: Keyword arguments passed to actor constructor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cfg</span><span class="p">:</span> <span class="n">ServiceConfig</span><span class="p">,</span>
        <span class="n">actor_def</span><span class="p">,</span>
        <span class="n">actor_args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">actor_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span> <span class="o">=</span> <span class="n">cfg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actor_def</span> <span class="o">=</span> <span class="n">actor_def</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actor_args</span> <span class="o">=</span> <span class="n">actor_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actor_kwargs</span> <span class="o">=</span> <span class="n">actor_kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id_session_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Initialize metrics collection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="o">=</span> <span class="n">ServiceMetrics</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Replica initialization queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">__initialize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the service and starts the health loop.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting service up with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">num_replicas</span><span class="si">}</span><span class="s2"> replicas.&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize the routers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_router</span> <span class="o">=</span> <span class="n">RoundRobinRouter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_router</span> <span class="o">=</span> <span class="n">SessionRouter</span><span class="p">(</span><span class="n">fallback_router</span><span class="o">=</span><span class="n">LeastLoadedRouter</span><span class="p">())</span>

        <span class="c1"># Initialize all replicas</span>
        <span class="n">replicas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_replicas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">num_replicas</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_replicas</span><span class="p">):</span>
            <span class="n">replica</span> <span class="o">=</span> <span class="n">Replica</span><span class="p">(</span>
                <span class="n">idx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
                <span class="n">proc_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">to_process_config</span><span class="p">(),</span>
                <span class="n">max_concurrent_requests</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">replica_max_concurrent_requests</span><span class="p">,</span>
                <span class="n">return_first_rank_result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">return_first_rank_result</span><span class="p">,</span>
                <span class="n">actor_def</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_actor_def</span><span class="p">,</span>
                <span class="n">actor_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_actor_args</span><span class="p">,</span>
                <span class="n">actor_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_actor_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">replicas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Queued </span><span class="si">{</span><span class="n">num_replicas</span><span class="si">}</span><span class="s2"> replicas for initialization. Total replicas: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Initialize all replicas in parallel</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">replicas</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="o">=</span> <span class="n">replicas</span>

        <span class="c1"># Start the health loop in the background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_health_loop</span><span class="p">(</span><span class="n">poll_rate_s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">health_poll_rate</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routes a function call to the appropriate replica with load balancing and fault tolerance.</span>

<span class="sd">        This is the core routing method that handles:</span>
<span class="sd">        - Session-based routing for stateful calls</span>
<span class="sd">        - Round-robin load balancing for stateless calls</span>
<span class="sd">        - Custom routing based on context hints</span>
<span class="sd">        - Automatic retry on replica failures</span>
<span class="sd">        - Request queuing and processing</span>

<span class="sd">        Args:</span>
<span class="sd">            sess_id: Optional session ID for stateful routing</span>
<span class="sd">            function: Name of the actor endpoint to call</span>
<span class="sd">            *args: Positional arguments to pass to the endpoint</span>
<span class="sd">            **kwargs: Keyword arguments to pass to the endpoint</span>

<span class="sd">        Returns:</span>
<span class="sd">            The result from the actor endpoint execution</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If no healthy replicas are available</span>
<span class="sd">            Exception: Any exception raised by the actor endpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check context variables for session state if no explicit sess_id</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">_session_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ctx</span><span class="p">:</span>
                <span class="n">sess_id</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">[</span><span class="s2">&quot;session_id&quot;</span><span class="p">]</span>

        <span class="n">replica</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_replica</span><span class="p">(</span><span class="n">sess_id</span><span class="p">)</span>

        <span class="c1"># Create a ServiceRequest object to queue</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">ServiceRequest</span><span class="p">(</span>
            <span class="n">session_id</span><span class="o">=</span><span class="n">sess_id</span><span class="p">,</span>
            <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">future</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="c1"># Queue the request using replica&#39;s method</span>
        <span class="k">await</span> <span class="n">replica</span><span class="o">.</span><span class="n">enqueue_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># Wait for the result</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">request</span><span class="o">.</span><span class="n">future</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># If the replica failed, try to retry once</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">replica</span><span class="o">.</span><span class="n">healthy</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Replica </span><span class="si">{</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="si">}</span><span class="s2"> failed during request, retrying on healthy replica. Exception: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retry_request_on_healthy_replica</span><span class="p">(</span>
                    <span class="n">sess_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="k">raise</span>

<div class="viewcode-block" id="Service.call_all">
<a class="viewcode-back" href="../../../../api_service.html#forge.controller.service.service.Service.call_all">[docs]</a>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">call_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Broadcasts a function call to all healthy replicas and returns results as a list.</span>

<span class="sd">        Args:</span>
<span class="sd">            function: Name of the actor endpoint to call</span>
<span class="sd">            *args: Positional arguments to pass to the endpoint</span>
<span class="sd">            **kwargs: Keyword arguments to pass to the endpoint</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of results from all healthy replicas</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If no healthy replicas are available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">healthy_replicas</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No healthy replicas available for broadcast call&quot;</span><span class="p">)</span>

        <span class="c1"># Create requests for all healthy replicas</span>
        <span class="n">requests</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="n">request</span> <span class="o">=</span> <span class="n">ServiceRequest</span><span class="p">(</span>
                <span class="n">session_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Broadcast calls don&#39;t use sessions</span>
                <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="n">future</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">requests</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">replica</span><span class="p">,</span> <span class="n">request</span><span class="p">))</span>

        <span class="c1"># Enqueue all requests</span>
        <span class="k">for</span> <span class="n">replica</span><span class="p">,</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">requests</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">replica</span><span class="o">.</span><span class="n">enqueue_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># Wait for all results</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">replica</span><span class="p">,</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">requests</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">request</span><span class="o">.</span><span class="n">future</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Request to replica </span><span class="si">{</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="si">}</span><span class="s2"> failed during broadcast: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="c1"># Add None for failed replicas to maintain indexing</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>


    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_retry_request_on_healthy_replica</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retries a failed request on a healthy replica.&quot;&quot;&quot;</span>
        <span class="c1"># Force reassignment to a healthy replica (only for session-based calls)</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sess_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>

        <span class="c1"># Retry the call (this will assign to a new healthy replica)</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">sess_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_migrate_remaining_requests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failed_replica</span><span class="p">:</span> <span class="n">Replica</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Migrates remaining requests from a failed replica to healthy replicas.&quot;&quot;&quot;</span>
        <span class="n">migrated_requests</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Collect all remaining requests</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">failed_replica</span><span class="o">.</span><span class="n">request_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">request</span> <span class="o">=</span> <span class="n">failed_replica</span><span class="o">.</span><span class="n">request_queue</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
                <span class="n">migrated_requests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">QueueEmpty</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">migrated_requests</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Migrating </span><span class="si">%d</span><span class="s2"> requests from failed replica </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">migrated_requests</span><span class="p">),</span>
            <span class="n">failed_replica</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Find healthy replicas</span>
        <span class="n">healthy_replicas</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">failed_replica</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="c1"># No healthy replicas, fail all requests</span>
            <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">migrated_requests</span><span class="p">:</span>
                <span class="n">request</span><span class="o">.</span><span class="n">future</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span>
                    <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No healthy replicas available&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Distribute requests among healthy replicas</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">request</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">migrated_requests</span><span class="p">):</span>
            <span class="n">target_replica</span> <span class="o">=</span> <span class="n">healthy_replicas</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">healthy_replicas</span><span class="p">)]</span>
            <span class="k">await</span> <span class="n">target_replica</span><span class="o">.</span><span class="n">enqueue_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

            <span class="c1"># Update session mapping if needed</span>
            <span class="n">sess_id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">session_id</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">sess_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">failed_replica</span><span class="o">.</span><span class="n">idx</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_replica</span><span class="o">.</span><span class="n">idx</span>

<div class="viewcode-block" id="Service.start_session">
<a class="viewcode-back" href="../../../../api_service.html#forge.controller.service.service.Service.start_session">[docs]</a>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">start_session</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts a new session for stateful request handling.</span>

<span class="sd">        Sessions enable request affinity to specific replicas, maintaining state</span>
<span class="sd">        consistency for workloads that require it. Each session gets a unique ID</span>
<span class="sd">        and is automatically assigned to the least loaded replica.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Unique session identifier for use in subsequent requests</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; session_id = await service.start_session()</span>
<span class="sd">            &gt;&gt;&gt; result = await service.my_endpoint(session_id, arg1, arg2)</span>
<span class="sd">            &gt;&gt;&gt; await service.terminate_session(session_id)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sess_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">session_id</span><span class="o">=</span><span class="n">sess_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>

        <span class="c1"># Update metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">sess_id</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_service_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates service-level metrics.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_sessions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_replicas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">healthy_replicas</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">)</span>
        <span class="c1"># Store direct references to replica metrics for aggregation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">replica_metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">:</span>
            <span class="c1"># Use the replica&#39;s own metrics directly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">replica_metrics</span><span class="p">[</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">replica</span><span class="o">.</span><span class="n">metrics</span>

<div class="viewcode-block" id="Service.get_metrics">
<a class="viewcode-back" href="../../../../api_service.html#forge.controller.service.service.Service.get_metrics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ServiceMetrics</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get comprehensive service metrics for monitoring and analysis.</span>

<span class="sd">        Returns detailed metrics including per-replica performance data,</span>
<span class="sd">        service-wide aggregations, and health status information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ServiceMetrics: Complete metrics object with replica and service data</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; metrics = service.get_metrics()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Request rate: {metrics.get_total_request_rate():.1f} req/s&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Queue depth: {metrics.get_avg_queue_depth():.1f}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span></div>


<div class="viewcode-block" id="Service.get_metrics_summary">
<a class="viewcode-back" href="../../../../api_service.html#forge.controller.service.service.Service.get_metrics_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_metrics_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a summary of key metrics for monitoring and debugging.</span>

<span class="sd">        Provides a structured summary of service and replica metrics in a format</span>
<span class="sd">        suitable for monitoring dashboards, logging, or debugging purposes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Structured metrics summary with service and per-replica data</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; summary = service.get_metrics_summary()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Healthy replicas: {summary[&#39;service&#39;][&#39;healthy_replicas&#39;]}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; for idx, metrics in summary[&#39;replicas&#39;].items():</span>
<span class="sd">            ...     print(f&quot;Replica {idx}: {metrics[&#39;request_rate&#39;]:.1f} req/s&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;service&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;total_sessions&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_sessions</span><span class="p">,</span>
                <span class="s2">&quot;healthy_replicas&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">healthy_replicas</span><span class="p">,</span>
                <span class="s2">&quot;total_replicas&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_replicas</span><span class="p">,</span>
                <span class="s2">&quot;total_request_rate&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_total_request_rate</span><span class="p">(),</span>
                <span class="s2">&quot;avg_queue_depth&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_avg_queue_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">),</span>
                <span class="s2">&quot;avg_capacity_utilization&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_avg_capacity_utilization</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span>
                <span class="p">),</span>
                <span class="s2">&quot;sessions_per_replica&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_sessions_per_replica</span><span class="p">(),</span>
            <span class="p">},</span>
            <span class="s2">&quot;replicas&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">:</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">replica</span><span class="o">.</span><span class="n">metrics</span>

            <span class="c1"># Count sessions assigned to this replica</span>
            <span class="n">assigned_sessions</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="mi">1</span>
                <span class="k">for</span> <span class="n">replica_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">replica_idx</span> <span class="o">==</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span>
            <span class="p">)</span>

            <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;replicas&quot;</span><span class="p">][</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;total_requests&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">total_requests</span><span class="p">,</span>
                <span class="s2">&quot;successful_requests&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">successful_requests</span><span class="p">,</span>
                <span class="s2">&quot;failed_requests&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">failed_requests</span><span class="p">,</span>
                <span class="s2">&quot;request_rate&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">get_request_rate</span><span class="p">(),</span>
                <span class="s2">&quot;avg_latency&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">get_avg_latency</span><span class="p">(),</span>
                <span class="s2">&quot;active_requests&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">active_requests</span><span class="p">,</span>  <span class="c1"># Get from replica</span>
                <span class="s2">&quot;queue_depth&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">qsize</span><span class="p">(),</span>
                <span class="s2">&quot;assigned_sessions&quot;</span><span class="p">:</span> <span class="n">assigned_sessions</span><span class="p">,</span>  <span class="c1"># Calculate from session map</span>
                <span class="s2">&quot;capacity_utilization&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">capacity_utilization</span><span class="p">,</span>  <span class="c1"># Get from replica</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">summary</span></div>


<div class="viewcode-block" id="Service.terminate_session">
<a class="viewcode-back" href="../../../../api_service.html#forge.controller.service.service.Service.terminate_session">[docs]</a>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">terminate_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Terminates an active session and cleans up associated resources.</span>

<span class="sd">        Removes the session from active tracking, clears replica assignments,</span>
<span class="sd">        and updates service metrics. Sessions should be terminated when no</span>
<span class="sd">        longer needed to free up resources.</span>

<span class="sd">        Args:</span>
<span class="sd">            sess_id: The unique session identifier to terminate</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; session_id = await service.start_session()</span>
<span class="sd">            &gt;&gt;&gt; # ... use session for requests ...</span>
<span class="sd">            &gt;&gt;&gt; await service.terminate_session(session_id)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Terminating session </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">)</span>

        <span class="c1"># Remove from active sessions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">session_id</span> <span class="o">!=</span> <span class="n">sess_id</span>
        <span class="p">]</span>

        <span class="c1"># Remove from session-replica mapping</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>

        <span class="c1"># Update metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span></div>


    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_health_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_rate_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Runs the health loop to monitor and recover replicas.</span>

<span class="sd">        This loop continuously checks the health of replicas and recovers</span>
<span class="sd">        failed replicas by reinitializing their proc_meshes. It also</span>
<span class="sd">        periodically updates service metrics to reflect the current state.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span><span class="p">:</span>
            <span class="c1"># Process any replicas that need recovery</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recover_replicas</span><span class="p">()</span>

            <span class="c1"># Check for failed replicas and recover them</span>
            <span class="n">failed_replicas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">replica</span><span class="o">.</span><span class="n">failed</span><span class="p">:</span>
                    <span class="n">failed_replicas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;[HEALTH LOOP] Detected </span><span class="si">%d</span><span class="s2"> failed replicas: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">),</span>
                    <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">)</span>

            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">poll_rate_s</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_get_replica</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Replica&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a replica for the given session ID.&quot;&quot;&quot;</span>
        <span class="n">healthy_replicas</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No session, use the default router</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_router</span><span class="o">.</span><span class="n">get_replica</span><span class="p">(</span><span class="n">healthy_replicas</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_router</span><span class="o">.</span><span class="n">get_replica</span><span class="p">(</span>
            <span class="n">healthy_replicas</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Service.stop">
<a class="viewcode-back" href="../../../../api_service.html#forge.controller.service.service.Service.stop">[docs]</a>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops the service and all managed replicas.</span>
<span class="sd">        This method should be called when the service is no longer needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Stopping service...&quot;</span><span class="p">)</span>
        <span class="c1"># Signal shutdown to health loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Wait for health loop to finish gracefully</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Health loop stopped gracefully.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Health loop didn&#39;t stop gracefully, cancelling...&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span>
                <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Health loop task cancelled.&quot;</span><span class="p">)</span>

        <span class="c1"># Stop all replicas using their stop method</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">replica</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span> <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">],</span>
            <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_recover_replicas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recovers unhealthy queued replicas.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Recovering replicas: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_recover</span><span class="p">(</span><span class="n">replica</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Recover a single replica.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">replica</span><span class="o">.</span><span class="n">recover</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Successfully recovered replica </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to recover replica </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">replica</span><span class="o">.</span><span class="n">mark_failed</span><span class="p">()</span>

        <span class="n">recovery_tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">_recover</span><span class="p">(</span><span class="n">replica</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span>
        <span class="p">]</span>

        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">recovery_tasks</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_migrate_replica_workload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica_to_remove</span><span class="p">:</span> <span class="n">Replica</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Migrates all workload from a replica that&#39;s being removed.&quot;&quot;&quot;</span>
        <span class="c1"># Migrate queued requests</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrate_remaining_requests</span><span class="p">(</span><span class="n">replica_to_remove</span><span class="p">)</span>

        <span class="c1"># Reassign sessions to other replicas</span>
        <span class="n">sessions_to_reassign</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sess_id</span>
            <span class="k">for</span> <span class="n">sess_id</span><span class="p">,</span> <span class="n">replica_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">replica_idx</span> <span class="o">==</span> <span class="n">replica_to_remove</span><span class="o">.</span><span class="n">idx</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">sess_id</span> <span class="ow">in</span> <span class="n">sessions_to_reassign</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Session </span><span class="si">%s</span><span class="s2"> will be reassigned on next request&quot;</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_get_internal_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets comprehensive internal state for testing purposes.</span>

<span class="sd">        This is intended for testing/debugging only, it should not</span>
<span class="sd">        be relied upon in actual production code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure metrics are up to date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="c1"># Session management state</span>
            <span class="s2">&quot;session_replica_map&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">),</span>  <span class="c1"># Copy for safety</span>
            <span class="s2">&quot;active_sessions&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">session_id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="p">],</span>
            <span class="s2">&quot;id_session_map&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_session_map</span><span class="p">),</span>  <span class="c1"># Copy for safety</span>
            <span class="c1"># Replica state</span>
            <span class="s2">&quot;replicas&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span>
                    <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="s2">&quot;healthy&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">healthy</span><span class="p">,</span>
                    <span class="s2">&quot;failed&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">failed</span><span class="p">,</span>
                    <span class="s2">&quot;active_requests&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">active_requests</span><span class="p">,</span>
                    <span class="s2">&quot;queue_size&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">request_queue</span><span class="o">.</span><span class="n">qsize</span><span class="p">(),</span>
                    <span class="s2">&quot;capacity_utilization&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">capacity_utilization</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span>
            <span class="p">],</span>
            <span class="c1"># Load balancing state</span>
            <span class="c1"># Service-level state</span>
            <span class="s2">&quot;total_replicas&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">),</span>
            <span class="s2">&quot;healthy_replica_count&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">),</span>
            <span class="s2">&quot;shutdown_requested&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span><span class="p">,</span>
            <span class="c1"># Metrics summary</span>
            <span class="s2">&quot;total_sessions&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="p">),</span>
            <span class="s2">&quot;replica_count&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Service(actor=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_actor_def</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">ServiceActor</span><span class="p">(</span><span class="n">Actor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distributed Actor Service Controller</span>

<span class="sd">    A service orchestration system that manages multiple replicas of actor-based</span>
<span class="sd">    services with fault tolerance and load balancing.</span>

<span class="sd">    Args:</span>
<span class="sd">        cfg: Service configuration including number of replicas, GPUs per replica, and health polling rate</span>
<span class="sd">        actor_def: Actor class definition to instantiate on each replica</span>
<span class="sd">        *actor_args: Positional arguments passed to actor constructor</span>
<span class="sd">        **actor_kwargs: Keyword arguments passed to actor constructor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">ServiceConfig</span><span class="p">,</span> <span class="n">actor_def</span><span class="p">,</span> <span class="n">actor_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_service</span> <span class="o">=</span> <span class="n">Service</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span> <span class="o">=</span> <span class="n">cfg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actor_def</span> <span class="o">=</span> <span class="n">actor_def</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_actor_kwargs</span> <span class="o">=</span> <span class="n">actor_kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id_session_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_replica_idx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># For round-robin load balancing</span>

        <span class="c1"># Initialize metrics collection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span> <span class="o">=</span> <span class="n">ServiceMetrics</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Replica initialization queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@endpoint</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">__initialize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the service and starts the health loop.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting service up with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">num_replicas</span><span class="si">}</span><span class="s2"> replicas.&quot;</span><span class="p">)</span>
        <span class="n">replicas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_replicas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">num_replicas</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_replicas</span><span class="p">):</span>
            <span class="n">replica</span> <span class="o">=</span> <span class="n">Replica</span><span class="p">(</span>
                <span class="n">idx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
                <span class="n">proc_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">to_process_config</span><span class="p">(),</span>
                <span class="n">max_concurrent_requests</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">replica_max_concurrent_requests</span><span class="p">,</span>
                <span class="n">return_first_rank_result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">return_first_rank_result</span><span class="p">,</span>
                <span class="n">actor_def</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_actor_def</span><span class="p">,</span>
                <span class="n">actor_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_actor_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">replicas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Queued </span><span class="si">{</span><span class="n">num_replicas</span><span class="si">}</span><span class="s2"> replicas for initialization. Total replicas: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Initialize all replicas in parallel</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">replicas</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="o">=</span> <span class="n">replicas</span>

        <span class="c1"># Start the health loop in the background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_health_loop</span><span class="p">(</span><span class="n">poll_rate_s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span><span class="o">.</span><span class="n">health_poll_rate</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@endpoint</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">sess_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routes a function call to the appropriate replica with load balancing and fault tolerance.</span>

<span class="sd">        This is the core routing method that handles:</span>
<span class="sd">        - Session-based routing for stateful calls</span>
<span class="sd">        - Round-robin load balancing for stateless calls</span>
<span class="sd">        - Custom routing based on context hints</span>
<span class="sd">        - Automatic retry on replica failures</span>
<span class="sd">        - Request queuing and processing</span>

<span class="sd">        Args:</span>
<span class="sd">            sess_id: Optional session ID for stateful routing</span>
<span class="sd">            function: Name of the actor endpoint to call</span>
<span class="sd">            *args: Positional arguments to pass to the endpoint</span>
<span class="sd">            **kwargs: Keyword arguments to pass to the endpoint</span>

<span class="sd">        Returns:</span>
<span class="sd">            The result from the actor endpoint execution</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If no healthy replicas are available</span>
<span class="sd">            Exception: Any exception raised by the actor endpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check context variables for session state if no explicit sess_id</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">_session_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ctx</span><span class="p">:</span>
                <span class="n">sess_id</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">[</span><span class="s2">&quot;session_id&quot;</span><span class="p">]</span>

        <span class="n">replica</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_replica</span><span class="p">(</span><span class="n">sess_id</span><span class="p">)</span>

        <span class="c1"># Create a ServiceRequest object to queue</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">ServiceRequest</span><span class="p">(</span>
            <span class="n">session_id</span><span class="o">=</span><span class="n">sess_id</span><span class="p">,</span>
            <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">future</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="c1"># Queue the request using replica&#39;s method</span>
        <span class="k">await</span> <span class="n">replica</span><span class="o">.</span><span class="n">enqueue_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># Wait for the result</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">request</span><span class="o">.</span><span class="n">future</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># If the replica failed, try to retry once</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">replica</span><span class="o">.</span><span class="n">healthy</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Replica </span><span class="si">{</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="si">}</span><span class="s2"> failed during request, retrying on healthy replica. Exception: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retry_request_on_healthy_replica</span><span class="p">(</span>
                    <span class="n">sess_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="k">raise</span>

    <span class="nd">@endpoint</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">call_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Broadcasts a function call to all healthy replicas and returns results as a list.</span>

<span class="sd">        Args:</span>
<span class="sd">            function: Name of the actor endpoint to call</span>
<span class="sd">            *args: Positional arguments to pass to the endpoint</span>
<span class="sd">            **kwargs: Keyword arguments to pass to the endpoint</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of results from all healthy replicas</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If no healthy replicas are available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">healthy_replicas</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No healthy replicas available for broadcast call&quot;</span><span class="p">)</span>

        <span class="c1"># Create requests for all healthy replicas</span>
        <span class="n">requests</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="n">request</span> <span class="o">=</span> <span class="n">ServiceRequest</span><span class="p">(</span>
                <span class="n">session_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Broadcast calls don&#39;t use sessions</span>
                <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="n">future</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">requests</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">replica</span><span class="p">,</span> <span class="n">request</span><span class="p">))</span>

        <span class="c1"># Enqueue all requests</span>
        <span class="k">for</span> <span class="n">replica</span><span class="p">,</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">requests</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">replica</span><span class="o">.</span><span class="n">enqueue_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># Wait for all results</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">replica</span><span class="p">,</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">requests</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">request</span><span class="o">.</span><span class="n">future</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Request to replica </span><span class="si">{</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="si">}</span><span class="s2"> failed during broadcast: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="c1"># Add None for failed replicas to maintain indexing</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_retry_request_on_healthy_replica</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retries a failed request on a healthy replica.&quot;&quot;&quot;</span>
        <span class="c1"># Force reassignment to a healthy replica (only for session-based calls)</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sess_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>

        <span class="c1"># Retry the call (this will assign to a new healthy replica)</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">sess_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_migrate_remaining_requests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failed_replica</span><span class="p">:</span> <span class="n">Replica</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Migrates remaining requests from a failed replica to healthy replicas.&quot;&quot;&quot;</span>
        <span class="n">migrated_requests</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Collect all remaining requests</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">failed_replica</span><span class="o">.</span><span class="n">request_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">request</span> <span class="o">=</span> <span class="n">failed_replica</span><span class="o">.</span><span class="n">request_queue</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
                <span class="n">migrated_requests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">QueueEmpty</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">migrated_requests</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Migrating </span><span class="si">%d</span><span class="s2"> requests from failed replica </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">migrated_requests</span><span class="p">),</span>
            <span class="n">failed_replica</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Find healthy replicas</span>
        <span class="n">healthy_replicas</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">failed_replica</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="c1"># No healthy replicas, fail all requests</span>
            <span class="k">for</span> <span class="n">request</span> <span class="ow">in</span> <span class="n">migrated_requests</span><span class="p">:</span>
                <span class="n">request</span><span class="o">.</span><span class="n">future</span><span class="o">.</span><span class="n">set_exception</span><span class="p">(</span>
                    <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No healthy replicas available&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Distribute requests among healthy replicas</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">request</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">migrated_requests</span><span class="p">):</span>
            <span class="n">target_replica</span> <span class="o">=</span> <span class="n">healthy_replicas</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">healthy_replicas</span><span class="p">)]</span>
            <span class="k">await</span> <span class="n">target_replica</span><span class="o">.</span><span class="n">enqueue_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

            <span class="c1"># Update session mapping if needed</span>
            <span class="n">sess_id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">session_id</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">sess_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">failed_replica</span><span class="o">.</span><span class="n">idx</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_replica</span><span class="o">.</span><span class="n">idx</span>

    <span class="nd">@endpoint</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">start_session</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts a new session for stateful request handling.</span>

<span class="sd">        Sessions enable request affinity to specific replicas, maintaining state</span>
<span class="sd">        consistency for workloads that require it. Each session gets a unique ID</span>
<span class="sd">        and is automatically assigned to the least loaded replica.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Unique session identifier for use in subsequent requests</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; session_id = await service.start_session()</span>
<span class="sd">            &gt;&gt;&gt; result = await service.my_endpoint(session_id, arg1, arg2)</span>
<span class="sd">            &gt;&gt;&gt; await service.terminate_session(session_id)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sess_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">session_id</span><span class="o">=</span><span class="n">sess_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>

        <span class="c1"># Update metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">sess_id</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_service_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates service-level metrics.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_sessions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_replicas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">healthy_replicas</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">)</span>
        <span class="c1"># Store direct references to replica metrics for aggregation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">replica_metrics</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">:</span>
            <span class="c1"># Use the replica&#39;s own metrics directly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">replica_metrics</span><span class="p">[</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">replica</span><span class="o">.</span><span class="n">metrics</span>

    <span class="nd">@endpoint</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ServiceMetrics</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get comprehensive service metrics for monitoring and analysis.</span>

<span class="sd">        Returns detailed metrics including per-replica performance data,</span>
<span class="sd">        service-wide aggregations, and health status information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ServiceMetrics: Complete metrics object with replica and service data</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; metrics = service.get_metrics()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Request rate: {metrics.get_total_request_rate():.1f} req/s&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Queue depth: {metrics.get_avg_queue_depth():.1f}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span>

    <span class="nd">@endpoint</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_metrics_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a summary of key metrics for monitoring and debugging.</span>

<span class="sd">        Provides a structured summary of service and replica metrics in a format</span>
<span class="sd">        suitable for monitoring dashboards, logging, or debugging purposes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Structured metrics summary with service and per-replica data</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; summary = service.get_metrics_summary()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Healthy replicas: {summary[&#39;service&#39;][&#39;healthy_replicas&#39;]}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; for idx, metrics in summary[&#39;replicas&#39;].items():</span>
<span class="sd">            ...     print(f&quot;Replica {idx}: {metrics[&#39;request_rate&#39;]:.1f} req/s&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;service&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;total_sessions&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_sessions</span><span class="p">,</span>
                <span class="s2">&quot;healthy_replicas&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">healthy_replicas</span><span class="p">,</span>
                <span class="s2">&quot;total_replicas&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">total_replicas</span><span class="p">,</span>
                <span class="s2">&quot;total_request_rate&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_total_request_rate</span><span class="p">(),</span>
                <span class="s2">&quot;avg_queue_depth&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_avg_queue_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">),</span>
                <span class="s2">&quot;avg_capacity_utilization&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_avg_capacity_utilization</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span>
                <span class="p">),</span>
                <span class="s2">&quot;sessions_per_replica&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metrics</span><span class="o">.</span><span class="n">get_sessions_per_replica</span><span class="p">(),</span>
            <span class="p">},</span>
            <span class="s2">&quot;replicas&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">:</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">replica</span><span class="o">.</span><span class="n">metrics</span>

            <span class="c1"># Count sessions assigned to this replica</span>
            <span class="n">assigned_sessions</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="mi">1</span>
                <span class="k">for</span> <span class="n">replica_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">replica_idx</span> <span class="o">==</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span>
            <span class="p">)</span>

            <span class="n">summary</span><span class="p">[</span><span class="s2">&quot;replicas&quot;</span><span class="p">][</span><span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;total_requests&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">total_requests</span><span class="p">,</span>
                <span class="s2">&quot;successful_requests&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">successful_requests</span><span class="p">,</span>
                <span class="s2">&quot;failed_requests&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">failed_requests</span><span class="p">,</span>
                <span class="s2">&quot;request_rate&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">get_request_rate</span><span class="p">(),</span>
                <span class="s2">&quot;avg_latency&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">get_avg_latency</span><span class="p">(),</span>
                <span class="s2">&quot;active_requests&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">active_requests</span><span class="p">,</span>  <span class="c1"># Get from replica</span>
                <span class="s2">&quot;queue_depth&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">qsize</span><span class="p">(),</span>
                <span class="s2">&quot;assigned_sessions&quot;</span><span class="p">:</span> <span class="n">assigned_sessions</span><span class="p">,</span>  <span class="c1"># Calculate from session map</span>
                <span class="s2">&quot;capacity_utilization&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">capacity_utilization</span><span class="p">,</span>  <span class="c1"># Get from replica</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">summary</span>

    <span class="nd">@endpoint</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">terminate_session</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Terminates an active session and cleans up associated resources.</span>

<span class="sd">        Removes the session from active tracking, clears replica assignments,</span>
<span class="sd">        and updates service metrics. Sessions should be terminated when no</span>
<span class="sd">        longer needed to free up resources.</span>

<span class="sd">        Args:</span>
<span class="sd">            sess_id: The unique session identifier to terminate</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; session_id = await service.start_session()</span>
<span class="sd">            &gt;&gt;&gt; # ... use session for requests ...</span>
<span class="sd">            &gt;&gt;&gt; await service.terminate_session(session_id)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Terminating session </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">)</span>

        <span class="c1"># Remove from active sessions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">session_id</span> <span class="o">!=</span> <span class="n">sess_id</span>
        <span class="p">]</span>

        <span class="c1"># Remove from session-replica mapping</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>

        <span class="c1"># Update metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_health_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_rate_s</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Runs the health loop to monitor and recover replicas.</span>

<span class="sd">        This loop continuously checks the health of replicas and recovers</span>
<span class="sd">        failed replicas by reinitializing their proc_meshes. It also</span>
<span class="sd">        periodically updates service metrics to reflect the current state.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span><span class="p">:</span>
            <span class="c1"># Process any replicas that need recovery</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recover_replicas</span><span class="p">()</span>

            <span class="c1"># Check for failed replicas and recover them</span>
            <span class="n">failed_replicas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">replica</span><span class="o">.</span><span class="n">failed</span><span class="p">:</span>
                    <span class="n">failed_replicas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;[HEALTH LOOP] Detected </span><span class="si">%d</span><span class="s2"> failed replicas: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">),</span>
                    <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">failed_replicas</span><span class="p">)</span>

            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">poll_rate_s</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_next_replica</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Replica&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the next replica using round-robin selection.&quot;&quot;&quot;</span>
        <span class="n">healthy_replicas</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No healthy replicas available for load balancing&quot;</span><span class="p">)</span>

        <span class="c1"># Simple round-robin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_replica_idx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_replica_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">healthy_replicas</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">healthy_replicas</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_replica_idx</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_least_loaded_replica</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Replica&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the replica with the lowest load.&quot;&quot;&quot;</span>
        <span class="n">healthy_replicas</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">healthy_replicas</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No healthy replicas available for session assignment&quot;</span><span class="p">)</span>

        <span class="c1"># Use the replica&#39;s current_load property</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">healthy_replicas</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">replica</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">current_load</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_get_replica</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Replica&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a replica for the given session ID.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No session, use round-robin load balancing</span>
            <span class="n">replica</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_replica</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">replica</span>

        <span class="c1"># Session-based routing</span>
        <span class="k">if</span> <span class="n">sess_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">:</span>
            <span class="n">replica_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>
            <span class="c1"># Find the replica with this index</span>
            <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span> <span class="o">==</span> <span class="n">replica_idx</span> <span class="ow">and</span> <span class="n">replica</span><span class="o">.</span><span class="n">healthy</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">replica</span>
            <span class="c1"># If the replica is no longer healthy, remove from session map and reassign</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>

        <span class="c1"># New session, assign to least loaded replica</span>
        <span class="n">replica</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_least_loaded_replica</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Assigning session </span><span class="si">%s</span><span class="s2"> to replica </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">,</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">replica</span>

    <span class="nd">@endpoint</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Stopping service...&quot;</span><span class="p">)</span>
        <span class="c1"># Signal shutdown to health loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Wait for health loop to finish gracefully</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Health loop stopped gracefully.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Health loop didn&#39;t stop gracefully, cancelling...&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_health_task</span>
                <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Health loop task cancelled.&quot;</span><span class="p">)</span>

        <span class="c1"># Stop all replicas using their stop method</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">replica</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span> <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">],</span>
            <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_recover_replicas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recovers unhealthy queued replicas.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Recovering replicas: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_recover</span><span class="p">(</span><span class="n">replica</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Recover a single replica.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">replica</span><span class="o">.</span><span class="n">recover</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Successfully recovered replica </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to recover replica </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">replica</span><span class="o">.</span><span class="n">mark_failed</span><span class="p">()</span>

        <span class="n">recovery_tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">_recover</span><span class="p">(</span><span class="n">replica</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span>
        <span class="p">]</span>

        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">recovery_tasks</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_replicas_to_recover</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_migrate_replica_workload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replica_to_remove</span><span class="p">:</span> <span class="n">Replica</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Migrates all workload from a replica that&#39;s being removed.&quot;&quot;&quot;</span>
        <span class="c1"># Migrate queued requests</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrate_remaining_requests</span><span class="p">(</span><span class="n">replica_to_remove</span><span class="p">)</span>

        <span class="c1"># Reassign sessions to other replicas</span>
        <span class="n">sessions_to_reassign</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sess_id</span>
            <span class="k">for</span> <span class="n">sess_id</span><span class="p">,</span> <span class="n">replica_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">replica_idx</span> <span class="o">==</span> <span class="n">replica_to_remove</span><span class="o">.</span><span class="n">idx</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">sess_id</span> <span class="ow">in</span> <span class="n">sessions_to_reassign</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">[</span><span class="n">sess_id</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Session </span><span class="si">%s</span><span class="s2"> will be reassigned on next request&quot;</span><span class="p">,</span> <span class="n">sess_id</span><span class="p">)</span>

    <span class="nd">@endpoint</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_internal_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets comprehensive internal state for testing purposes.</span>

<span class="sd">        This is intended for testing/debugging only, it should not</span>
<span class="sd">        be relied upon in actual production code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure metrics are up to date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_service_metrics</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="c1"># Session management state</span>
            <span class="s2">&quot;session_replica_map&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_session_replica_map</span><span class="p">),</span>  <span class="c1"># Copy for safety</span>
            <span class="s2">&quot;active_sessions&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">session_id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="p">],</span>
            <span class="s2">&quot;id_session_map&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_session_map</span><span class="p">),</span>  <span class="c1"># Copy for safety</span>
            <span class="c1"># Replica state</span>
            <span class="s2">&quot;replicas&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span>
                    <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="s2">&quot;healthy&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">healthy</span><span class="p">,</span>
                    <span class="s2">&quot;failed&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">failed</span><span class="p">,</span>
                    <span class="s2">&quot;active_requests&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">active_requests</span><span class="p">,</span>
                    <span class="s2">&quot;queue_size&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">request_queue</span><span class="o">.</span><span class="n">qsize</span><span class="p">(),</span>
                    <span class="s2">&quot;capacity_utilization&quot;</span><span class="p">:</span> <span class="n">replica</span><span class="o">.</span><span class="n">capacity_utilization</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">replica</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span>
            <span class="p">],</span>
            <span class="c1"># Load balancing state</span>
            <span class="s2">&quot;next_replica_idx&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_replica_idx</span><span class="p">,</span>
            <span class="c1"># Service-level state</span>
            <span class="s2">&quot;total_replicas&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">),</span>
            <span class="s2">&quot;healthy_replica_count&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">healthy</span><span class="p">),</span>
            <span class="s2">&quot;shutdown_requested&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shutdown_requested</span><span class="p">,</span>
            <span class="c1"># Metrics summary</span>
            <span class="s2">&quot;total_sessions&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_active_sessions</span><span class="p">),</span>
            <span class="s2">&quot;replica_count&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replicas</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Service(actor=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_actor_def</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span>
</pre></div>

                </article>
              
  </article>
  
              
              
                <footer class="bd-footer-article">
                  <div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item">
<div class="feedback">
  
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-behavior="tutorial-rating" data-count="1" data-value="1">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="2" data-value="2">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="3" data-value="3">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="4" data-value="4">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="5" data-value="5">★</span>
        
    </div>
</div>

  <div class="feedback-send">
    <button class="feedback-btn"
            onclick="openGitHubIssue()"
            data-bs-title="Create a GitHub Issue"
            data-bs-placement="bottom"
            data-bs-toggle="tooltip"
            data-gtm="feedback-btn-click">Send Feedback
    </button>
  </div>
</div>

<div class="prev-next-area">
</div>

<div class="footer-info">
  <p class="copyright">
    
  </p>

  <p class="theme-version">
    Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
  </p>
</div>
</div>
  
</div>
                </footer>
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  


<style>
.site-footer {
    padding: 20px 40px;
    height: 60px !important;
}

@media screen and (min-width: 768px) {
    .site-footer {
        padding: 20px 40px;
    }
}

.site-footer .privacy-policy {
    border-top: none;
    margin-top: 0px;
}

.site-footer .privacy-policy .copyright {
    padding-top: 0;
}
</style>


<footer class="site-footer">

    <div class="privacy-policy">
      <div class="copyright">
      
        <p>
           Copyright © 2025 Meta Platforms, Inc
        </p>
        
      </div>
    </div>


  </div>
</footer>

<div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../../_static/img/pytorch-x.svg">
  </div>
</div>
  
  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  <script type="application/ld+json">
    {
       "@context": "https://schema.org",
       "@type": "Article",
       "name": "forge.controller.service.service",
       "headline": "forge.controller.service.service",
       "description": "PyTorch Documentation. Explore PyTorch, an open-source machine learning library that accelerates the path from research prototyping to production deployment. Discover tutorials, API references, and guides to help you build and deploy deep learning models efficiently.",
       "url": "/_modules/forge/controller/service/service.html",
       "articleBody": "Source code for forge.controller.service.service # Copyright (c) Meta Platforms, Inc. and affiliates. # All rights reserved. # # This source code is licensed under the BSD-style license found in the # LICENSE file in the root directory of this source tree. \"\"\" Distributed Actor Service Controller This module provides a robust service orchestration system for managing distributed actor-based workloads with automatic scaling, fault tolerance, and intelligent load balancing. The main Service class acts as a singleton controller that handles: - Fault tolerance with automatic replica recovery - Autoscaling based on real-time metrics - Load balancing across healthy replicas - Session management with context propagation - Comprehensive metrics collection and monitoring Example: Basic service setup: \u003e\u003e\u003e config = ServiceConfig( ... gpus_per_replica=1, ... num_replicas=3 ... ) \u003e\u003e\u003e service = Service(config, MyActorClass, *args, **kwargs) \u003e\u003e\u003e await service.__initialize__() Session-based usage: \u003e\u003e\u003e async with service.session(): ... result = await service.my_endpoint(arg1, arg2) \"\"\" import asyncio import logging import pprint import uuid from monarch.actor import Actor, endpoint from forge.controller.service.interface import _session_context, Session from forge.controller.service.metrics import ServiceMetrics from forge.controller.service.replica import Replica, ServiceRequest from forge.controller.service.router import ( LeastLoadedRouter, RoundRobinRouter, SessionRouter, ) from forge.types import ServiceConfig logger = logging.getLogger(__name__) logger.setLevel(logging.DEBUG) [docs] class Service: \"\"\" Actor-less implementation of Service. This is a temporary solution to disable nested actors, which is proving problematic temporarily. Args: cfg: Service configuration including number of replicas, GPUs per replica, and health polling rate actor_def: Actor class definition to instantiate on each replica *actor_args: Positional arguments passed to actor constructor **actor_kwargs: Keyword arguments passed to actor constructor \"\"\" def __init__( self, cfg: ServiceConfig, actor_def, actor_args: tuple, actor_kwargs: dict, ): self._cfg = cfg self._replicas = [] self._actor_def = actor_def self._actor_args = actor_args self._actor_kwargs = actor_kwargs self._active_sessions = [] self._id_session_map = {} self._session_replica_map: dict[str, int] = {} # Initialize metrics collection self._metrics = ServiceMetrics() self._health_task = None self._shutdown_requested = False # Replica initialization queue self._replicas_to_recover = [] async def __initialize__(self): \"\"\"Initializes the service and starts the health loop.\"\"\" logger.debug(f\"Starting service up with {self._cfg.num_replicas} replicas.\") # Initialize the routers self._default_router = RoundRobinRouter() self._session_router = SessionRouter(fallback_router=LeastLoadedRouter()) # Initialize all replicas replicas = [] num_replicas = self._cfg.num_replicas for i in range(num_replicas): replica = Replica( idx=len(self._replicas) + i, proc_config=self._cfg.to_process_config(), max_concurrent_requests=self._cfg.replica_max_concurrent_requests, return_first_rank_result=self._cfg.return_first_rank_result, actor_def=self._actor_def, actor_args=self._actor_args, actor_kwargs=self._actor_kwargs, ) replicas.append(replica) logger.debug( f\"Queued {num_replicas} replicas for initialization. Total replicas: {len(self._replicas)}\" ) # Initialize all replicas in parallel await asyncio.gather(*[r.initialize() for r in replicas]) self._replicas = replicas # Start the health loop in the background self._health_task = asyncio.create_task( self._health_loop(poll_rate_s=self._cfg.health_poll_rate) ) async def _call(self, sess_id: str | None, function: str, *args, **kwargs): \"\"\" Routes a function call to the appropriate replica with load balancing and fault tolerance. This is the core routing method that handles: - Session-based routing for stateful calls - Round-robin load balancing for stateless calls - Custom routing based on context hints - Automatic retry on replica failures - Request queuing and processing Args: sess_id: Optional session ID for stateful routing function: Name of the actor endpoint to call *args: Positional arguments to pass to the endpoint **kwargs: Keyword arguments to pass to the endpoint Returns: The result from the actor endpoint execution Raises: RuntimeError: If no healthy replicas are available Exception: Any exception raised by the actor endpoint \"\"\" # Check context variables for session state if no explicit sess_id if sess_id is None: ctx = _session_context.get(None) if ctx: sess_id = ctx[\"session_id\"] replica = await self._get_replica(sess_id) # Create a ServiceRequest object to queue request = ServiceRequest( session_id=sess_id, function=function, args=args, kwargs=kwargs, future=asyncio.Future(), ) # Queue the request using replica\u0027s method await replica.enqueue_request(request) # Wait for the result try: return await request.future except Exception as e: # If the replica failed, try to retry once if not replica.healthy: logger.debug( f\"Replica {replica.idx} failed during request, retrying on healthy replica. Exception: {e}\" ) return await self._retry_request_on_healthy_replica( sess_id, function, *args, **kwargs ) raise [docs] async def call_all(self, function: str, *args, **kwargs) -\u003e list: \"\"\" Broadcasts a function call to all healthy replicas and returns results as a list. Args: function: Name of the actor endpoint to call *args: Positional arguments to pass to the endpoint **kwargs: Keyword arguments to pass to the endpoint Returns: List of results from all healthy replicas Raises: RuntimeError: If no healthy replicas are available \"\"\" healthy_replicas = [r for r in self._replicas if r.healthy] if not healthy_replicas: raise RuntimeError(\"No healthy replicas available for broadcast call\") # Create requests for all healthy replicas requests = [] for replica in healthy_replicas: request = ServiceRequest( session_id=None, # Broadcast calls don\u0027t use sessions function=function, args=args, kwargs=kwargs, future=asyncio.Future(), ) requests.append((replica, request)) # Enqueue all requests for replica, request in requests: await replica.enqueue_request(request) # Wait for all results results = [] for replica, request in requests: try: result = await request.future results.append(result) except Exception as e: logger.warning( f\"Request to replica {replica.idx} failed during broadcast: {e}\" ) # Add None for failed replicas to maintain indexing results.append(None) return results async def _retry_request_on_healthy_replica( self, sess_id: str | None, function: str, *args, **kwargs ): \"\"\"Retries a failed request on a healthy replica.\"\"\" # Force reassignment to a healthy replica (only for session-based calls) if sess_id is not None and sess_id in self._session_replica_map: del self._session_replica_map[sess_id] # Retry the call (this will assign to a new healthy replica) return await self._call(sess_id, function, *args, **kwargs) async def _migrate_remaining_requests(self, failed_replica: Replica): \"\"\"Migrates remaining requests from a failed replica to healthy replicas.\"\"\" migrated_requests = [] # Collect all remaining requests while not failed_replica.request_queue.empty(): try: request = failed_replica.request_queue.get_nowait() migrated_requests.append(request) except asyncio.QueueEmpty: break if not migrated_requests: return logger.debug( \"Migrating %d requests from failed replica %d\", len(migrated_requests), failed_replica.idx, ) # Find healthy replicas healthy_replicas = [ r for r in self._replicas if r.healthy and r != failed_replica ] if not healthy_replicas: # No healthy replicas, fail all requests for request in migrated_requests: request.future.set_exception( RuntimeError(\"No healthy replicas available\") ) return # Distribute requests among healthy replicas for i, request in enumerate(migrated_requests): target_replica = healthy_replicas[i % len(healthy_replicas)] await target_replica.enqueue_request(request) # Update session mapping if needed sess_id = request.session_id if ( sess_id in self._session_replica_map and self._session_replica_map[sess_id] == failed_replica.idx ): self._session_replica_map[sess_id] = target_replica.idx [docs] async def start_session(self) -\u003e str: \"\"\" Starts a new session for stateful request handling. Sessions enable request affinity to specific replicas, maintaining state consistency for workloads that require it. Each session gets a unique ID and is automatically assigned to the least loaded replica. Returns: str: Unique session identifier for use in subsequent requests Example: \u003e\u003e\u003e session_id = await service.start_session() \u003e\u003e\u003e result = await service.my_endpoint(session_id, arg1, arg2) \u003e\u003e\u003e await service.terminate_session(session_id) \"\"\" sess_id = str(uuid.uuid4()) session = Session(session_id=sess_id) self._active_sessions.append(session) # Update metrics self._update_service_metrics() return sess_id def _update_service_metrics(self): \"\"\"Updates service-level metrics.\"\"\" self._metrics.total_sessions = len(self._active_sessions) self._metrics.total_replicas = len(self._replicas) self._metrics.healthy_replicas = sum(1 for r in self._replicas if r.healthy) # Store direct references to replica metrics for aggregation self._metrics.replica_metrics = {} for replica in self._replicas: # Use the replica\u0027s own metrics directly self._metrics.replica_metrics[replica.idx] = replica.metrics [docs] def get_metrics(self) -\u003e ServiceMetrics: \"\"\" Get comprehensive service metrics for monitoring and analysis. Returns detailed metrics including per-replica performance data, service-wide aggregations, and health status information. Returns: ServiceMetrics: Complete metrics object with replica and service data Example: \u003e\u003e\u003e metrics = service.get_metrics() \u003e\u003e\u003e print(f\"Request rate: {metrics.get_total_request_rate():.1f} req/s\") \u003e\u003e\u003e print(f\"Queue depth: {metrics.get_avg_queue_depth():.1f}\") \"\"\" self._update_service_metrics() return self._metrics [docs] def get_metrics_summary(self) -\u003e dict: \"\"\" Get a summary of key metrics for monitoring and debugging. Provides a structured summary of service and replica metrics in a format suitable for monitoring dashboards, logging, or debugging purposes. Returns: dict: Structured metrics summary with service and per-replica data Example: \u003e\u003e\u003e summary = service.get_metrics_summary() \u003e\u003e\u003e print(f\"Healthy replicas: {summary[\u0027service\u0027][\u0027healthy_replicas\u0027]}\") \u003e\u003e\u003e for idx, metrics in summary[\u0027replicas\u0027].items(): ... print(f\"Replica {idx}: {metrics[\u0027request_rate\u0027]:.1f} req/s\") \"\"\" self._update_service_metrics() summary = { \"service\": { \"total_sessions\": self._metrics.total_sessions, \"healthy_replicas\": self._metrics.healthy_replicas, \"total_replicas\": self._metrics.total_replicas, \"total_request_rate\": self._metrics.get_total_request_rate(), \"avg_queue_depth\": self._metrics.get_avg_queue_depth(self._replicas), \"avg_capacity_utilization\": self._metrics.get_avg_capacity_utilization( self._replicas ), \"sessions_per_replica\": self._metrics.get_sessions_per_replica(), }, \"replicas\": {}, } for replica in self._replicas: metrics = replica.metrics # Count sessions assigned to this replica assigned_sessions = sum( 1 for replica_idx in self._session_replica_map.values() if replica_idx == replica.idx ) summary[\"replicas\"][replica.idx] = { \"total_requests\": metrics.total_requests, \"successful_requests\": metrics.successful_requests, \"failed_requests\": metrics.failed_requests, \"request_rate\": metrics.get_request_rate(), \"avg_latency\": metrics.get_avg_latency(), \"active_requests\": replica.active_requests, # Get from replica \"queue_depth\": replica.qsize(), \"assigned_sessions\": assigned_sessions, # Calculate from session map \"capacity_utilization\": replica.capacity_utilization, # Get from replica } return summary [docs] async def terminate_session(self, sess_id: str): \"\"\" Terminates an active session and cleans up associated resources. Removes the session from active tracking, clears replica assignments, and updates service metrics. Sessions should be terminated when no longer needed to free up resources. Args: sess_id: The unique session identifier to terminate Example: \u003e\u003e\u003e session_id = await service.start_session() \u003e\u003e\u003e # ... use session for requests ... \u003e\u003e\u003e await service.terminate_session(session_id) \"\"\" logger.debug(\"Terminating session %s\", sess_id) # Remove from active sessions self._active_sessions = [ s for s in self._active_sessions if s.session_id != sess_id ] # Remove from session-replica mapping if sess_id in self._session_replica_map: del self._session_replica_map[sess_id] # Update metrics self._update_service_metrics() async def _health_loop(self, poll_rate_s: float): \"\"\"Runs the health loop to monitor and recover replicas. This loop continuously checks the health of replicas and recovers failed replicas by reinitializing their proc_meshes. It also periodically updates service metrics to reflect the current state. \"\"\" while not self._shutdown_requested: # Process any replicas that need recovery await self._recover_replicas() # Check for failed replicas and recover them failed_replicas = [] for replica in self._replicas: if replica.failed: failed_replicas.append(replica) if any(failed_replicas): logger.debug( \"[HEALTH LOOP] Detected %d failed replicas: %s\", len(failed_replicas), pprint.pformat(failed_replicas), ) self._replicas_to_recover.extend(failed_replicas) await asyncio.sleep(poll_rate_s) async def _get_replica(self, sess_id: str | None) -\u003e \"Replica\": \"\"\"Get a replica for the given session ID.\"\"\" healthy_replicas = [r for r in self._replicas if r.healthy] if sess_id is None: # No session, use the default router return self._default_router.get_replica(healthy_replicas) return self._session_router.get_replica( healthy_replicas, sess_id, self._session_replica_map ) [docs] async def stop(self): \"\"\" Stops the service and all managed replicas. This method should be called when the service is no longer needed. \"\"\" logger.debug(\"Stopping service...\") # Signal shutdown to health loop self._shutdown_requested = True # Wait for health loop to finish gracefully if self._health_task is not None: try: await asyncio.wait_for(self._health_task, timeout=5.0) logger.info(\"Health loop stopped gracefully.\") except asyncio.TimeoutError: logger.warning(\"Health loop didn\u0027t stop gracefully, cancelling...\") self._health_task.cancel() try: await self._health_task except asyncio.CancelledError: logger.info(\"Health loop task cancelled.\") # Stop all replicas using their stop method await asyncio.gather( *[replica.stop() for replica in self._replicas], return_exceptions=True, ) async def _recover_replicas(self): \"\"\"Recovers unhealthy queued replicas.\"\"\" if not self._replicas_to_recover: return logger.debug( \"Recovering replicas: %s\", pprint.pformat(self._replicas_to_recover) ) async def _recover(replica): \"\"\"Recover a single replica.\"\"\" try: await replica.recover() logger.debug(\"Successfully recovered replica %d\", replica.idx) except Exception as e: logger.error(\"Failed to recover replica %d: %s\", replica.idx, e) replica.mark_failed() recovery_tasks = [ asyncio.create_task(_recover(replica)) for replica in self._replicas_to_recover ] await asyncio.gather(*recovery_tasks, return_exceptions=True) self._replicas_to_recover.clear() async def _migrate_replica_workload(self, replica_to_remove: Replica): \"\"\"Migrates all workload from a replica that\u0027s being removed.\"\"\" # Migrate queued requests await self._migrate_remaining_requests(replica_to_remove) # Reassign sessions to other replicas sessions_to_reassign = [ sess_id for sess_id, replica_idx in self._session_replica_map.items() if replica_idx == replica_to_remove.idx ] for sess_id in sessions_to_reassign: del self._session_replica_map[sess_id] logger.debug(\"Session %s will be reassigned on next request\", sess_id) async def _get_internal_state(self) -\u003e dict: \"\"\" Gets comprehensive internal state for testing purposes. This is intended for testing/debugging only, it should not be relied upon in actual production code. \"\"\" # Ensure metrics are up to date self._update_service_metrics() return { # Session management state \"session_replica_map\": dict(self._session_replica_map), # Copy for safety \"active_sessions\": [s.session_id for s in self._active_sessions], \"id_session_map\": dict(self._id_session_map), # Copy for safety # Replica state \"replicas\": [ { \"idx\": replica.idx, \"state\": replica.state.value, \"healthy\": replica.healthy, \"failed\": replica.failed, \"active_requests\": replica.active_requests, \"queue_size\": replica.request_queue.qsize(), \"capacity_utilization\": replica.capacity_utilization, } for replica in self._replicas ], # Load balancing state # Service-level state \"total_replicas\": len(self._replicas), \"healthy_replica_count\": sum(1 for r in self._replicas if r.healthy), \"shutdown_requested\": self._shutdown_requested, # Metrics summary \"total_sessions\": len(self._active_sessions), \"replica_count\": len(self._replicas), } def __repr__(self): return f\"Service(actor={self._actor_def.__name__})\" class ServiceActor(Actor): \"\"\" Distributed Actor Service Controller A service orchestration system that manages multiple replicas of actor-based services with fault tolerance and load balancing. Args: cfg: Service configuration including number of replicas, GPUs per replica, and health polling rate actor_def: Actor class definition to instantiate on each replica *actor_args: Positional arguments passed to actor constructor **actor_kwargs: Keyword arguments passed to actor constructor \"\"\" def __init__(self, cfg: ServiceConfig, actor_def, actor_kwargs: dict): self._service = Service() self._cfg = cfg self._replicas = [] self._actor_def = actor_def self._actor_kwargs = actor_kwargs self._active_sessions = [] self._id_session_map = {} self._session_replica_map: dict[str, int] = {} self._next_replica_idx = 0 # For round-robin load balancing # Initialize metrics collection self._metrics = ServiceMetrics() self._health_task = None self._shutdown_requested = False # Replica initialization queue self._replicas_to_recover = [] @endpoint async def __initialize__(self): \"\"\"Initializes the service and starts the health loop.\"\"\" logger.debug(f\"Starting service up with {self._cfg.num_replicas} replicas.\") replicas = [] num_replicas = self._cfg.num_replicas for i in range(num_replicas): replica = Replica( idx=len(self._replicas) + i, proc_config=self._cfg.to_process_config(), max_concurrent_requests=self._cfg.replica_max_concurrent_requests, return_first_rank_result=self._cfg.return_first_rank_result, actor_def=self._actor_def, actor_kwargs=self._actor_kwargs, ) replicas.append(replica) logger.debug( f\"Queued {num_replicas} replicas for initialization. Total replicas: {len(self._replicas)}\" ) # Initialize all replicas in parallel await asyncio.gather(*[r.initialize() for r in replicas]) self._replicas = replicas # Start the health loop in the background self._health_task = asyncio.create_task( self._health_loop(poll_rate_s=self._cfg.health_poll_rate) ) @endpoint async def call(self, sess_id: str | None, function: str, *args, **kwargs): return await self._call(sess_id, function, *args, **kwargs) async def _call(self, sess_id: str | None, function: str, *args, **kwargs): \"\"\" Routes a function call to the appropriate replica with load balancing and fault tolerance. This is the core routing method that handles: - Session-based routing for stateful calls - Round-robin load balancing for stateless calls - Custom routing based on context hints - Automatic retry on replica failures - Request queuing and processing Args: sess_id: Optional session ID for stateful routing function: Name of the actor endpoint to call *args: Positional arguments to pass to the endpoint **kwargs: Keyword arguments to pass to the endpoint Returns: The result from the actor endpoint execution Raises: RuntimeError: If no healthy replicas are available Exception: Any exception raised by the actor endpoint \"\"\" # Check context variables for session state if no explicit sess_id if sess_id is None: ctx = _session_context.get(None) if ctx: sess_id = ctx[\"session_id\"] replica = await self._get_replica(sess_id) # Create a ServiceRequest object to queue request = ServiceRequest( session_id=sess_id, function=function, args=args, kwargs=kwargs, future=asyncio.Future(), ) # Queue the request using replica\u0027s method await replica.enqueue_request(request) # Wait for the result try: return await request.future except Exception as e: # If the replica failed, try to retry once if not replica.healthy: logger.debug( f\"Replica {replica.idx} failed during request, retrying on healthy replica. Exception: {e}\" ) return await self._retry_request_on_healthy_replica( sess_id, function, *args, **kwargs ) raise @endpoint async def call_all(self, function: str, *args, **kwargs) -\u003e list: \"\"\" Broadcasts a function call to all healthy replicas and returns results as a list. Args: function: Name of the actor endpoint to call *args: Positional arguments to pass to the endpoint **kwargs: Keyword arguments to pass to the endpoint Returns: List of results from all healthy replicas Raises: RuntimeError: If no healthy replicas are available \"\"\" healthy_replicas = [r for r in self._replicas if r.healthy] if not healthy_replicas: raise RuntimeError(\"No healthy replicas available for broadcast call\") # Create requests for all healthy replicas requests = [] for replica in healthy_replicas: request = ServiceRequest( session_id=None, # Broadcast calls don\u0027t use sessions function=function, args=args, kwargs=kwargs, future=asyncio.Future(), ) requests.append((replica, request)) # Enqueue all requests for replica, request in requests: await replica.enqueue_request(request) # Wait for all results results = [] for replica, request in requests: try: result = await request.future results.append(result) except Exception as e: logger.warning( f\"Request to replica {replica.idx} failed during broadcast: {e}\" ) # Add None for failed replicas to maintain indexing results.append(None) return results async def _retry_request_on_healthy_replica( self, sess_id: str | None, function: str, *args, **kwargs ): \"\"\"Retries a failed request on a healthy replica.\"\"\" # Force reassignment to a healthy replica (only for session-based calls) if sess_id is not None and sess_id in self._session_replica_map: del self._session_replica_map[sess_id] # Retry the call (this will assign to a new healthy replica) return await self._call(sess_id, function, *args, **kwargs) async def _migrate_remaining_requests(self, failed_replica: Replica): \"\"\"Migrates remaining requests from a failed replica to healthy replicas.\"\"\" migrated_requests = [] # Collect all remaining requests while not failed_replica.request_queue.empty(): try: request = failed_replica.request_queue.get_nowait() migrated_requests.append(request) except asyncio.QueueEmpty: break if not migrated_requests: return logger.debug( \"Migrating %d requests from failed replica %d\", len(migrated_requests), failed_replica.idx, ) # Find healthy replicas healthy_replicas = [ r for r in self._replicas if r.healthy and r != failed_replica ] if not healthy_replicas: # No healthy replicas, fail all requests for request in migrated_requests: request.future.set_exception( RuntimeError(\"No healthy replicas available\") ) return # Distribute requests among healthy replicas for i, request in enumerate(migrated_requests): target_replica = healthy_replicas[i % len(healthy_replicas)] await target_replica.enqueue_request(request) # Update session mapping if needed sess_id = request.session_id if ( sess_id in self._session_replica_map and self._session_replica_map[sess_id] == failed_replica.idx ): self._session_replica_map[sess_id] = target_replica.idx @endpoint async def start_session(self) -\u003e str: \"\"\" Starts a new session for stateful request handling. Sessions enable request affinity to specific replicas, maintaining state consistency for workloads that require it. Each session gets a unique ID and is automatically assigned to the least loaded replica. Returns: str: Unique session identifier for use in subsequent requests Example: \u003e\u003e\u003e session_id = await service.start_session() \u003e\u003e\u003e result = await service.my_endpoint(session_id, arg1, arg2) \u003e\u003e\u003e await service.terminate_session(session_id) \"\"\" sess_id = str(uuid.uuid4()) session = Session(session_id=sess_id) self._active_sessions.append(session) # Update metrics self._update_service_metrics() return sess_id def _update_service_metrics(self): \"\"\"Updates service-level metrics.\"\"\" self._metrics.total_sessions = len(self._active_sessions) self._metrics.total_replicas = len(self._replicas) self._metrics.healthy_replicas = sum(1 for r in self._replicas if r.healthy) # Store direct references to replica metrics for aggregation self._metrics.replica_metrics = {} for replica in self._replicas: # Use the replica\u0027s own metrics directly self._metrics.replica_metrics[replica.idx] = replica.metrics @endpoint def get_metrics(self) -\u003e ServiceMetrics: \"\"\" Get comprehensive service metrics for monitoring and analysis. Returns detailed metrics including per-replica performance data, service-wide aggregations, and health status information. Returns: ServiceMetrics: Complete metrics object with replica and service data Example: \u003e\u003e\u003e metrics = service.get_metrics() \u003e\u003e\u003e print(f\"Request rate: {metrics.get_total_request_rate():.1f} req/s\") \u003e\u003e\u003e print(f\"Queue depth: {metrics.get_avg_queue_depth():.1f}\") \"\"\" self._update_service_metrics() return self._metrics @endpoint def get_metrics_summary(self) -\u003e dict: \"\"\" Get a summary of key metrics for monitoring and debugging. Provides a structured summary of service and replica metrics in a format suitable for monitoring dashboards, logging, or debugging purposes. Returns: dict: Structured metrics summary with service and per-replica data Example: \u003e\u003e\u003e summary = service.get_metrics_summary() \u003e\u003e\u003e print(f\"Healthy replicas: {summary[\u0027service\u0027][\u0027healthy_replicas\u0027]}\") \u003e\u003e\u003e for idx, metrics in summary[\u0027replicas\u0027].items(): ... print(f\"Replica {idx}: {metrics[\u0027request_rate\u0027]:.1f} req/s\") \"\"\" self._update_service_metrics() summary = { \"service\": { \"total_sessions\": self._metrics.total_sessions, \"healthy_replicas\": self._metrics.healthy_replicas, \"total_replicas\": self._metrics.total_replicas, \"total_request_rate\": self._metrics.get_total_request_rate(), \"avg_queue_depth\": self._metrics.get_avg_queue_depth(self._replicas), \"avg_capacity_utilization\": self._metrics.get_avg_capacity_utilization( self._replicas ), \"sessions_per_replica\": self._metrics.get_sessions_per_replica(), }, \"replicas\": {}, } for replica in self._replicas: metrics = replica.metrics # Count sessions assigned to this replica assigned_sessions = sum( 1 for replica_idx in self._session_replica_map.values() if replica_idx == replica.idx ) summary[\"replicas\"][replica.idx] = { \"total_requests\": metrics.total_requests, \"successful_requests\": metrics.successful_requests, \"failed_requests\": metrics.failed_requests, \"request_rate\": metrics.get_request_rate(), \"avg_latency\": metrics.get_avg_latency(), \"active_requests\": replica.active_requests, # Get from replica \"queue_depth\": replica.qsize(), \"assigned_sessions\": assigned_sessions, # Calculate from session map \"capacity_utilization\": replica.capacity_utilization, # Get from replica } return summary @endpoint async def terminate_session(self, sess_id: str): \"\"\" Terminates an active session and cleans up associated resources. Removes the session from active tracking, clears replica assignments, and updates service metrics. Sessions should be terminated when no longer needed to free up resources. Args: sess_id: The unique session identifier to terminate Example: \u003e\u003e\u003e session_id = await service.start_session() \u003e\u003e\u003e # ... use session for requests ... \u003e\u003e\u003e await service.terminate_session(session_id) \"\"\" logger.debug(\"Terminating session %s\", sess_id) # Remove from active sessions self._active_sessions = [ s for s in self._active_sessions if s.session_id != sess_id ] # Remove from session-replica mapping if sess_id in self._session_replica_map: del self._session_replica_map[sess_id] # Update metrics self._update_service_metrics() async def _health_loop(self, poll_rate_s: float): \"\"\"Runs the health loop to monitor and recover replicas. This loop continuously checks the health of replicas and recovers failed replicas by reinitializing their proc_meshes. It also periodically updates service metrics to reflect the current state. \"\"\" while not self._shutdown_requested: # Process any replicas that need recovery await self._recover_replicas() # Check for failed replicas and recover them failed_replicas = [] for replica in self._replicas: if replica.failed: failed_replicas.append(replica) if any(failed_replicas): logger.debug( \"[HEALTH LOOP] Detected %d failed replicas: %s\", len(failed_replicas), pprint.pformat(failed_replicas), ) self._replicas_to_recover.extend(failed_replicas) await asyncio.sleep(poll_rate_s) def _get_next_replica(self) -\u003e \"Replica\": \"\"\"Get the next replica using round-robin selection.\"\"\" healthy_replicas = [r for r in self._replicas if r.healthy] if not healthy_replicas: raise RuntimeError(\"No healthy replicas available for load balancing\") # Simple round-robin self._next_replica_idx = (self._next_replica_idx + 1) % len(healthy_replicas) return healthy_replicas[self._next_replica_idx] def _get_least_loaded_replica(self) -\u003e \"Replica\": \"\"\"Get the replica with the lowest load.\"\"\" healthy_replicas = [r for r in self._replicas if r.healthy] if not healthy_replicas: raise RuntimeError(\"No healthy replicas available for session assignment\") # Use the replica\u0027s current_load property return min(healthy_replicas, key=lambda replica: replica.current_load) async def _get_replica(self, sess_id: str | None) -\u003e \"Replica\": \"\"\"Get a replica for the given session ID.\"\"\" if sess_id is None: # No session, use round-robin load balancing replica = self._get_next_replica() return replica # Session-based routing if sess_id in self._session_replica_map: replica_idx = self._session_replica_map[sess_id] # Find the replica with this index for replica in self._replicas: if replica.idx == replica_idx and replica.healthy: return replica # If the replica is no longer healthy, remove from session map and reassign del self._session_replica_map[sess_id] # New session, assign to least loaded replica replica = self._get_least_loaded_replica() self._session_replica_map[sess_id] = replica.idx logger.debug(\"Assigning session %s to replica %d\", sess_id, replica.idx) return replica @endpoint async def stop(self): logger.debug(\"Stopping service...\") # Signal shutdown to health loop self._shutdown_requested = True # Wait for health loop to finish gracefully if self._health_task is not None: try: await asyncio.wait_for(self._health_task, timeout=5.0) logger.info(\"Health loop stopped gracefully.\") except asyncio.TimeoutError: logger.warning(\"Health loop didn\u0027t stop gracefully, cancelling...\") self._health_task.cancel() try: await self._health_task except asyncio.CancelledError: logger.info(\"Health loop task cancelled.\") # Stop all replicas using their stop method await asyncio.gather( *[replica.stop() for replica in self._replicas], return_exceptions=True, ) async def _recover_replicas(self): \"\"\"Recovers unhealthy queued replicas.\"\"\" if not self._replicas_to_recover: return logger.debug( \"Recovering replicas: %s\", pprint.pformat(self._replicas_to_recover) ) async def _recover(replica): \"\"\"Recover a single replica.\"\"\" try: await replica.recover() logger.debug(\"Successfully recovered replica %d\", replica.idx) except Exception as e: logger.error(\"Failed to recover replica %d: %s\", replica.idx, e) replica.mark_failed() recovery_tasks = [ asyncio.create_task(_recover(replica)) for replica in self._replicas_to_recover ] await asyncio.gather(*recovery_tasks, return_exceptions=True) self._replicas_to_recover.clear() async def _migrate_replica_workload(self, replica_to_remove: Replica): \"\"\"Migrates all workload from a replica that\u0027s being removed.\"\"\" # Migrate queued requests await self._migrate_remaining_requests(replica_to_remove) # Reassign sessions to other replicas sessions_to_reassign = [ sess_id for sess_id, replica_idx in self._session_replica_map.items() if replica_idx == replica_to_remove.idx ] for sess_id in sessions_to_reassign: del self._session_replica_map[sess_id] logger.debug(\"Session %s will be reassigned on next request\", sess_id) @endpoint def _get_internal_state(self) -\u003e dict: \"\"\" Gets comprehensive internal state for testing purposes. This is intended for testing/debugging only, it should not be relied upon in actual production code. \"\"\" # Ensure metrics are up to date self._update_service_metrics() return { # Session management state \"session_replica_map\": dict(self._session_replica_map), # Copy for safety \"active_sessions\": [s.session_id for s in self._active_sessions], \"id_session_map\": dict(self._id_session_map), # Copy for safety # Replica state \"replicas\": [ { \"idx\": replica.idx, \"state\": replica.state.value, \"healthy\": replica.healthy, \"failed\": replica.failed, \"active_requests\": replica.active_requests, \"queue_size\": replica.request_queue.qsize(), \"capacity_utilization\": replica.capacity_utilization, } for replica in self._replicas ], # Load balancing state \"next_replica_idx\": self._next_replica_idx, # Service-level state \"total_replicas\": len(self._replicas), \"healthy_replica_count\": sum(1 for r in self._replicas if r.healthy), \"shutdown_requested\": self._shutdown_requested, # Metrics summary \"total_sessions\": len(self._active_sessions), \"replica_count\": len(self._replicas), } def __repr__(self): return f\"Service(actor={self._actor_def.__name__})\"",
       "author": {
         "@type": "Organization",
         "name": "PyTorch Contributors",
         "url": "https://pytorch.org"
       },
       "image": "../../../../_static/img/pytorch_seo.png",
       "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "/_modules/forge/controller/service/service.html"
       },
       "datePublished": "2023-01-01T00:00:00Z",
       "dateModified": "2023-01-01T00:00:00Z"
     }
 </script>
  <script>
    // Tutorials Call to action event tracking
    $("[data-behavior='call-to-action-event']").on('click', function () {
      fbq('trackCustom', "Download", {
        tutorialTitle: $('h1:first').text(),
        downloadLink: this.href,
        tutorialLink: window.location.href,
        downloadTitle: $(this).attr("data-response")
      });
      if (typeof gtag === 'function') {
        gtag('event', 'click', {
          'event_category': $(this).attr("data-response"),
          'event_label': $("h1").first().text(),
          'tutorial_link': window.location.href
        });
      }
    });
  </script>
  
  </body>
</html>